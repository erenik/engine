/// Emil Hedemalm
/// 2014-08-09
/// Particle effects

#include "ToolParticles.h"

#include "TextureManager.h"

#include "Graphics/GraphicsManager.h"
#include "Graphics/Messages/GraphicsMessage.h"

#include "Graphics/Camera/Camera.h"

/// Particle system class for handling at least some of the particle effects generated by the player tools.
ToolParticleSystem::ToolParticleSystem()
: ParticleSystem("ToolParticleSystem")
{
	pointsOnly = false;
    diffuse = NULL;
    maxParticles = 10000;
    particlesToProcess = maxParticles;
    emissionsPerSecond = 10000;
    maxRange = 1000;
    maxLifeTime = 5.0f;

    maxRangeSq = maxRange * maxRange;
    lifeDurations = new float[maxParticles];
	lifeTime = new float[maxParticles];
    positions = new Vector3f[maxParticles];
    velocities = new Vector3f[maxParticles];
    colors = new Vector4f[maxParticles];
	maxDistanceSquared = new float[maxParticles];
	distanceTraveledSquared = new float[maxParticles];
	scale = new float[maxParticles];

	diffuse = TexMan.GetTextureBySource("Particles/Particle");
	assert(diffuse);
	Graphics.QueueMessage(new GMBufferTexture(diffuse));
	emissionVelocity = 1.0f;

    for(int i = 0; i < maxParticles; ++i)
	{
    //    velocities[i].x += sideVelocityRange * (rand()%201-100) * 0.01f;
    //    velocities[i].y += sideVelocityRange * (rand()%201-100) * 0.01f;
    //    velocities[i].z = primaryVelocity * (rand()%81 + 20) * 0.01f;
    //    lifeDuration[i] = maxLifeTime;
//		lifeTime[i] = maxLifeTime;
  //      colors[i] = color;
    }
    color = Vector4f(0.1f, 0.2f, 0.4f, 1.0f);

	livingParticles = 0;
}

ToolParticleSystem::~ToolParticleSystem()
{
	if (maxDistanceSquared)
		delete[] maxDistanceSquared;
	maxDistanceSquared = NULL;
	if (distanceTraveledSquared)
		delete[] distanceTraveledSquared;
	distanceTraveledSquared = NULL;
	if (scale)
		delete[] scale;
	scale = NULL;
}

/** Processes the particles within the system, moving them wherever they are going or performing whatever transformation they should ungergo.
	If emitters are attached to this system they may also automatically create or emit new particles.
*/
void ToolParticleSystem::Process(float timeInSeconds)
{
    /// Prepare some data
    int spawnedThisFrame = 0;
	int toSpawnThisFrameTotal = (int)floor(emissionsPerSecond * timeInSeconds * emissionRatio+0.5f);
    int toSpawn = toSpawnThisFrameTotal;
    Matrix4f & modelMatrix = relativeTo->transformationMatrix;
    Matrix4d & rotationMatrix = relativeTo->rotationMatrix;
    Vector3f velocity;

	// Move the particles toward their destination. Constant speed.
	for (int i = 0; i < livingParticles; ++i)
	{
		bool die = false;
		Vector3f distanceToTravel = velocities[i] * timeInSeconds;
		positions[i] = positions[i] + distanceToTravel;
		lifeDurations[i] += timeInSeconds;

		distanceTraveledSquared[i] += distanceToTravel.LengthSquared();
		// Kill it.
		if (lifeDurations[i] > lifeTime[i])
		{
			die = true;
		}
		else if (lifeDurations[i] >= 5.f)
		{
			die = true;
		}
		if (die){
			--livingParticles;
			// Move last index to here.
			positions[i] = positions[livingParticles];
			distanceTraveledSquared[i] = distanceTraveledSquared[livingParticles];
			maxDistanceSquared[i] = maxDistanceSquared[livingParticles];
			lifeDurations[i] = lifeDurations[livingParticles];
			velocities[i] = velocities[livingParticles];
			scale[i] = scale[livingParticles];
			colors[i] = colors[livingParticles];
			lifeTime[i] = lifeTime[livingParticles];
		}

	}

	/// Spawn new particles as the emitters dictate.
	for (int i = 0; i < emitters.Size(); ++i)
	{
		ToolParticleEmitter * emitter = (ToolParticleEmitter *) emitters[i];
		if (!emitter->enabled)
			continue;

		int particlesToSpawn = emitter->ParticlesToSpawn(timeInSeconds);

		for (int j = 0; j < particlesToSpawn; ++j)
		{
			if (livingParticles >= maxParticles)
			{
				std::cout<<"\nMax particles reached!";
				break;
			}

			// Get a free particle index?
			emitter->GetNewParticle(positions[livingParticles], 
				velocities[livingParticles], 
				lifeTime[livingParticles], 
				colors[livingParticles],
				scale[livingParticles]
			);
			distanceTraveledSquared[livingParticles] = 0;
			lifeDurations[livingParticles] = 0;
			++livingParticles;
		}
	}
}

/// Renders the particles
void ToolParticleSystem::Render(GraphicsState * graphicsState)
{
    /// Based on the optimization level, will probably be pow(0.5, optimizationLevel);
    optimizationLevel = pow(0.5f, graphicsState->optimizationLevel);
    if (optimizationLevel == 0)
        return;
    assert(optimizationLevel > 0);
    /// Calculate particles to process based on the graphicsState's optimization level.
    particlesToProcess = (int) (optimizationLevel * maxParticles);

    glUseProgram(0);
    glMatrixMode(GL_PROJECTION);
    glLoadMatrixf(graphicsState->projectionMatrixF.getPointer());
    glMatrixMode(GL_MODELVIEW);
    Matrix4f viewMatrix = graphicsState->viewMatrixF.getPointer();
    Matrix4f modelMatrix;
  //  if (relativeTo)
  //      modelMatrix = relativeTo->transformationMatrix;
    Matrix4f modelView = viewMatrix * modelMatrix;
    glLoadMatrixf(modelView.getPointer());
    glDisable(GL_TEXTURE_2D);
    glDisable(GL_LIGHTING);
    glDisable(GL_COLOR_MATERIAL);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE);
	// PointsU ONLU!
	if (pointsOnly){
		glBegin(GL_POINTS);
		for (int i = 0; i < livingParticles; ++i){
			if (lifeDurations[i] >= lifeTime[i])
				continue;
			glColor4f(colors[i].x, colors[i].y, colors[i].z, colors[i].w);
			Vector3f & p = positions[i];
			glVertex3f(p.x, p.y, p.z);
		}
		glEnd();
	}
	else {
		/// Set mipmap level too?
		int value;
		glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, &value);
		// 9987 9729
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glEnable(GL_TEXTURE_2D);
		glBindTexture(GL_TEXTURE_2D, diffuse->glid);
		Vector3f leftBase, upBase, left, up;
		leftBase = graphicsState->camera->LeftVector() * particleSize;
		upBase = graphicsState->camera->UpVector() * particleSize;
		glBegin(GL_QUADS);
		float optimizedAlpha = 1 / optimizationLevel;
		for (int i = 0; i < livingParticles; ++i)
		{
			glColor4f(colors[i].x, colors[i].y, colors[i].z, colors[i].w);
			float sizeRatio = scale[i];
			left = leftBase * sizeRatio;
			up = upBase * sizeRatio;
			Vector3f & p = positions[i];

			glTexCoord2f(0.0f, 0.0f);
			glVertex3f(p.x + left.x + up.x, p.y + left.y + up.y, p.z + left.z + up.z);

		//	glColor4f(colors[i].x , colors[i].y - 1.0f, colors[i].z - 1.0f, colors[i].w * lifeDuration[i] / lifeTime);

			glTexCoord2f(1.0f, 0.0f);
			glVertex3f(p.x + left.x - up.x, p.y + left.y - up.y, p.z + left.z - up.z);

			glTexCoord2f(1.0f, 1.0f);
			glVertex3f(p.x - left.x - up.x, p.y - left.y - up.y, p.z - left.z - up.z);

			glTexCoord2f(0.0f, 1.0f);
			glVertex3f(p.x - left.x + up.x, p.y - left.y + up.y, p.z - left.z + up.z);
		}
		glEnd();
	}
}


ToolParticleEmitter::ToolParticleEmitter()
: ParticleEmitter()
{
	particleVelocity = 5.f;
	lifetime = 5.f;
	direction = Vector3f(1,0,0);
	particleScale = 1.f;
}

int ToolParticleEmitter::ParticlesToSpawn(float timeInSeconds)
{
	if (!enabled)
		return 0;
	// 10 per second?
	return 10;
}

/// Stuff.
bool ToolParticleEmitter::GetNewParticle(Vector3f & position, Vector3f & velocity, float & particleLifetime, Vector4f & particleColor, float & newParticleScale)
{
	position = this->position;
	velocity = particleVelocity * direction;
	particleLifetime = lifetime;
	particleColor = this->color;
	newParticleScale = particleScale;
	return true;
}


/// sets positions and updates direction as well as max distance.
void ToolParticleEmitter::SetPositionAndTarget(Vector3f startPosition, Vector3f targetPos)
{
	position = startPosition;
	// Set target to be the target we're aiming at.
	targetPosition = targetPos;
	direction = (targetPosition - position).NormalizedCopy();
	float distance = (targetPosition - position).Length();
	lifetime = distance / particleVelocity;
}