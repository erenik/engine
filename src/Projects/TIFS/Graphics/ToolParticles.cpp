/// Emil Hedemalm
/// 2014-08-09
/// Particle effects

#include "ToolParticles.h"

#include "TextureManager.h"

#include "Graphics/GraphicsManager.h"
#include "Graphics/Messages/GraphicsMessage.h"

#include "Graphics/Camera/Camera.h"

/// Particle system class for handling at least some of the particle effects generated by the player tools.
ToolParticleSystem::ToolParticleSystem()
: ParticleSystem("ToolParticleSystem", true)
{

    for(int i = 0; i < maxParticles; ++i)
	{
    //    velocities[i].x += sideVelocityRange * (rand()%201-100) * 0.01f;
    //    velocities[i].y += sideVelocityRange * (rand()%201-100) * 0.01f;
    //    velocities[i].z = primaryVelocity * (rand()%81 + 20) * 0.01f;
    //    lifeDuration[i] = maxLifeTime;
//		lifeTime[i] = maxLifeTime;
  //      colors[i] = color;
    }
    color = Vector4f(0.1f, 0.2f, 0.4f, 1.0f);

	livingParticles = 0;
}

ToolParticleSystem::~ToolParticleSystem()
{
	/*
	if (maxDistanceSquared)
		delete[] maxDistanceSquared;
	maxDistanceSquared = NULL;
	if (distanceTraveledSquared)
		delete[] distanceTraveledSquared;
	distanceTraveledSquared = NULL;
	if (scale)
		delete[] scale;
	scale = NULL;
	*/
}

/** Processes the particles within the system, moving them wherever they are going or performing whatever transformation they should ungergo.
	If emitters are attached to this system they may also automatically create or emit new particles.
*/
void ToolParticleSystem::Process(float timeInSeconds)
{
	float velocityDecay = pow(0.55f, timeInSeconds);
	/// Move/Process all alive particles
	for (int i = 0; i < aliveParticles; ++i)
	{
		positions[i] += velocities[i] * timeInSeconds;
		velocities[i] *= velocityDecay;
		lifeDurations[i] += timeInSeconds;
		// If duration has elapsed life-time..
		if (lifeDurations[i] > lifeTimes[i])
		{
			int lastIndex = aliveParticles - 1;
			// Kill it, by moving in the last used data to replace it.
			positions[i] = positions[lastIndex];
			velocities[i] = velocities[lastIndex];
			lifeDurations[i] = lifeDurations[lastIndex];
			colors[i] = colors[lastIndex];
			lifeTimes[i] = lifeTimes[lastIndex];
			scales[i] = scales[lastIndex];

			// Decrement i so we don't skip processing of the one we moved back.
			--i;
			// Decrement alive particles.
			--aliveParticles;
		}
	}
}

/// Renders the particles
void ToolParticleSystem::Render(GraphicsState * graphicsState)
{

}


ToolParticleEmitter::ToolParticleEmitter()
: ParticleEmitter()
{
	particleVelocity = 5.f;
	lifetime = 5.f;
	direction = Vector3f(1,0,0);
	particleScale = 1.f;
}

/// Default new particle.
bool ToolParticleEmitter::GetNewParticle(Vector3f & position, Vector3f & velocity)
{

	return false;
}
/// Extended particle emission.
bool ToolParticleEmitter::GetNewParticle(Vector3f & position, Vector3f & velocity, float & newParticleScale, float & particleLifetime, Vector4f & particleColor)
{
	position = this->position;
	velocity = particleVelocity * direction;
	particleLifetime = lifetime;
	particleColor = this->color;
	newParticleScale = particleScale;
	return true;
}


/// Stuff.

/*
bool ToolParticleEmitter::GetNewParticle(Vector3f & position, Vector3f & velocity, float & particleLifetime, Vector4f & particleColor, float & newParticleScale)
{
	position = this->position;
	velocity = particleVelocity * direction;
	particleLifetime = lifetime;
	particleColor = this->color;
	newParticleScale = particleScale;
	return true;
}
*/

/// sets positions and updates direction as well as max distance.
void ToolParticleEmitter::SetPositionAndTarget(ConstVec3fr startPosition, ConstVec3fr targetPos)
{
	position = startPosition;
	// Set target to be the target we're aiming at.
	targetPosition = targetPos;
	direction = (targetPosition - position).NormalizedCopy();
	float distance = (targetPosition - position).Length();
	lifetime = distance / particleVelocity;
}