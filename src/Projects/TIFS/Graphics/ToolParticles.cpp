/// Emil Hedemalm
/// 2014-08-09
/// Particle effects

#include "ToolParticles.h"

#include "TextureManager.h"

#include "Graphics/GraphicsManager.h"
#include "Graphics/Messages/GraphicsMessage.h"

#include "Graphics/Camera/Camera.h"

#include "Graphics/FrameStatistics.h"

/// Particle system class for handling at least some of the particle effects generated by the player tools.
ToolParticleSystem::ToolParticleSystem()
: ParticleSystem("ToolParticleSystem", true)
{

	shaderName = "ToolParticles";
	modelName = "obj/Sphere6.obj";
	color = Vector4f(0.1f, 0.2f, 0.4f, 1.0f);
	livingParticles = 0;
}

ToolParticleSystem::~ToolParticleSystem()
{
}

/// Integrates all particles.
void ToolParticleSystem::ProcessParticles(float & timeInSeconds)
{
	Timer timer;
	timer.Start();
#ifdef USE_SSE
	__m128 sseTime = _mm_load1_ps(&timeInSeconds);
#endif
	/// Move/Process all alive particles
//	const Vector3f wind = weather->globalWind;
	for (int i = 0; i < aliveParticles; ++i)
	{
#ifdef SSE_PARTICLES
		positionsSSE[i].data = _mm_add_ps(positionsSSE[i].data, _mm_mul_ps(sseTime, velocitiesSSE[i].data));
#else // Not SSE_PARTICLES
		// Using SSE commands straight away reduced computation time to like 1 ms from 150ms when many particles were around (towards 500k somewhere)
#ifdef USE_SSE
		positions[i].data = _mm_add_ps(positions[i].data, _mm_mul_ps(sseTime, _mm_add_ps(velocities[i].data, weather->globalWind.data)));
#else
		positions[i] += (velocities[i] + weather->globalWind)* timeInSeconds;
#endif // USE_SSE
#endif // SSE_PARTICLES
	}
	timer.Stop();
	FrameStats.particleProcessingIntegrate += timer.GetMs();

	timer.Start();
	for (int i = 0; i < aliveParticles; ++i)
	{
#ifdef SSE_PARTICLES
		ldsSSE[i].y += timeInSeconds;	
#else // Not SSE_PARTICLES
		// No velocity decay.
		lifeDurations[i] += timeInSeconds;
#endif // SSE_PARTICLES
	}
	timer.Stop();
	FrameStats.particleProcessingOldify = timer.GetMs();


	timer.Start();
	for (int i = 0; i < aliveParticles; ++i)
	{
#ifdef SSE_PARTICLES
		if (ldsSSE[i].y > ldsSSE[i].x)
		{
			int lastIndex = aliveParticles - 1;
			positionsSSE[i] = positionsSSE[lastIndex];
			velocitiesSSE[i] = velocitiesSSE[lastIndex];
			colorsSSE[i] = colorsSSE[lastIndex];
			ldsSSE[i] = ldsSSE[lastIndex];
			// Decrement i so we don't skip processing of the one we moved back.
			--i;
			// Decrement alive particles.
			--aliveParticles;
		}			
#else // Not SSE_PARTICLES
			// If duration has elapsed life-time..
		if (lifeDurations[i] > lifeTimes[i])
		{
			int lastIndex = aliveParticles - 1;
			// Kill it, by moving in the last used data to replace it.
			positions[i] = positions[lastIndex];
			velocities[i] = velocities[lastIndex];
			lifeDurations[i] = lifeDurations[lastIndex];
			colors[i] = colors[lastIndex];
			lifeTimes[i] = lifeTimes[lastIndex];
			scales[i] = scales[lastIndex];

			// Decrement i so we don't skip processing of the one we moved back.
			--i;
			// Decrement alive particles.
			--aliveParticles;
		}
#endif
	}
	timer.Stop();
	FrameStats.particleProcessingRedead += timer.GetMs();
}


ToolParticleEmitter::ToolParticleEmitter()
: ParticleEmitter()
{
	emissionVelocity = 5.f;
	direction = Vector3f(1,0,0);
	scale = 1.f;
	particlesPerSecond = 500;
	targetPositionEmitter.type = EmitterType::SPHERE;
}

/// Default new particle.
bool ToolParticleEmitter::GetNewParticle(Vector3f & newPPos, Vector3f & velocity)
{
	// Emit randomly from around our position, toward the target position?
	// Get position
	Vector3f targetPosition;
	targetPositionEmitter.Position(targetPosition);
	Vector3f direction = targetPosition - position; 
	direction.Normalize();
	velocity = direction * emissionVelocity;
	newPPos = this->position;
	return false;
}
/// Extended particle emission.
bool ToolParticleEmitter::GetNewParticle(Vector3f & position, Vector3f & velocity, float & newParticleScale, float & lifetime, Vector4f & particleColor)
{
	position = this->position;
	velocity = emissionVelocity * direction;
	lifetime = particleLifeTime;
	particleColor = this->color;
	newParticleScale = scale;
	return true;
}


/// Stuff.

/*
bool ToolParticleEmitter::GetNewParticle(Vector3f & position, Vector3f & velocity, float & particleLifetime, Vector4f & particleColor, float & newParticleScale)
{
	position = this->position;
	velocity = particleVelocity * direction;
	particleLifetime = lifetime;
	particleColor = this->color;
	newParticleScale = particleScale;
	return true;
}
*/

/// sets positions and updates direction as well as max distance.
void ToolParticleEmitter::SetPositionAndTarget(ConstVec3fr startPosition, ConstVec3fr targetPos)
{
	position = startPosition;
	targetPosition = targetPos;
	// Set target to be the target we're aiming at.
	targetPositionEmitter.offset = targetPos;
	direction = (targetPosition - position).NormalizedCopy();
	float distance = (targetPosition - position).Length();
	particleLifeTime = distance / emissionVelocity;
	// Max 5 second particles?
	ClampFloat(particleLifeTime, 0, 5.f);
}